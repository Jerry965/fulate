<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.querySelector("#canvas");
      const canvasCtx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      function helper(options) {
        const state = {
          matrix: new DOMMatrix(),
          hasMatrixDirty: false
        };

        function applyTransform() {
          canvasCtx.setTransform(
            state.matrix.a,
            state.matrix.b,
            state.matrix.c,
            state.matrix.d,
            state.matrix.e,
            state.matrix.f
          );
        }

        function getLocalCenter() {
          return {
            x: options.width / 2,
            y: options.height / 2
          };
        }

        function globalToLocal(x, y) {
          const inverseMatrix = state.matrix.inverse();
          const point = new DOMPoint(x, y);
          const localPoint = point.matrixTransform(inverseMatrix);
          return { x: localPoint.x, y: localPoint.y };
        }

        return {
          getMatrix() {
            return state;
          },
          options,
          getLocalCenter,
          applyTransform,
          globalToLocal,
          getCenter() {
            const localCenter = getLocalCenter();
            const point = new DOMPoint(localCenter.x, localCenter.y);
            const transformedPoint = point.matrixTransform(state.matrix);
            return {
              x: transformedPoint.x,
              y: transformedPoint.y
            };
          },
          setRotate(angle, center = getLocalCenter()) {
            state.hasMatrixDirty = true;
            state.matrix
              .translateSelf(center.x, center.y)
              .rotateSelf(0, 0, angle)
              .translateSelf(-center.x, -center.y);
          },
          setTransform(x, y) {
            if (x === 0 && y === 0) return;
            state.hasMatrixDirty = true;
            state.matrix.translateSelf(x, y);
          },
          getCurrentAngle() {
            return Math.atan2(state.matrix.b, state.matrix.a) * (180 / Math.PI);
          },
          extendsMatrix(parentMatrix) {
            if (parentMatrix.hasMatrixDirty) {
              state.hasMatrixDirty = true;
              state.matrix.preMultiplySelf(parentMatrix.matrix);
            }
          },
          getGlobalPoint(localX = 0, localY = 0) {
            const localPoint = new DOMPoint(localX, localY);
            const globalPoint = localPoint.matrixTransform(state.matrix);
            return {
              x: globalPoint.x,
              y: globalPoint.y
            };
          },
          getBoundingBox() {
            const { width, height } = options;

            const corners = [
              new DOMPoint(0, 0), // 左上
              new DOMPoint(width, 0), // 右上
              new DOMPoint(width, height), // 右下
              new DOMPoint(0, height) // 左下
            ];

            const globalCorners = corners.map((corner) =>
              corner.matrixTransform(state.matrix)
            );

            // 计算 min/max
            let minX = Infinity,
              minY = Infinity;
            let maxX = -Infinity,
              maxY = -Infinity;

            globalCorners.forEach(({ x, y }) => {
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            });

            return {
              x: minX, // 包围盒左上角 x
              y: minY, // 包围盒左上角 y
              width: maxX - minX, // 包围盒宽度
              height: maxY - minY // 包围盒高度
            };
          },
          isPointInside(x, y) {
            const local = globalToLocal(x, y);
            return (
              local.x >= 0 &&
              local.x <= options.width &&
              local.y >= 0 &&
              local.y <= options.height
            );
          }
        };
      }

      let elements = [];

      function createElement(
        options,
        stack = {
          domPath: null
        }
      ) {
        const element = helper(options);
        element.setTransform(options.x, options.y);
        if (stack.domPath) {
          element.extendsMatrix(stack.domPath.getMatrix());
        }

        if (options.angle) {
          element.setRotate(options.angle);
        }

        canvasCtx.save();
        element.applyTransform();
        canvasCtx.fillStyle = options.backgroundColor ?? "transparent";
        canvasCtx.fillRect(0, 0, options.width, options.height);
        if (options.children) {
          options.children.forEach((child) => {
            element.parent = stack.domPath;
            createElement(child, {
              domPath: element
            });
          });
        }
        canvasCtx.restore();
        elements.push(element);
      }

      function render() {
        elements = [];
        createElement({
          x: 150,
          y: 20,
          width: 200,
          height: 200,
          angle: 45,
          backgroundColor: "red",
          children: [
            {
              x: 0,
              y: 20,
              width: 50,
              height: 50,
              backgroundColor: "blue"
              // angle: -45
            },
            {
              x: 170,
              y: 20,
              width: 50,
              height: 50,
              backgroundColor: "yellow"
              // angle: 0
            }
          ]
        });
      }

      render();

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        for (let index = 0; index < elements.length; index++) {
          const element = elements[index];
          const isInside = element.isPointInside(mouseX, mouseY);
          // 重绘并高亮
          canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
          render();

          if (isInside) {
            console.log(element.options.backgroundColor, "Mouse OVER");
            canvasCtx.save();
            canvasCtx.setTransform(1, 0, 0, 1, 0, 0);
            canvasCtx.fillStyle = "black";
            canvasCtx.fillText("Mouse OVER", 10, 20);
            canvasCtx.restore();
            break;
          }
        }
      });
    </script>
  </body>
</html>
